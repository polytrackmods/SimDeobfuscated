// @ts-check
/// <reference path="../types/globals.d.ts" />

importScripts(
    "../simlib/sha256.min.js",
    "../simlib/pako.min.js",
    "../simlib/three.min.js",
    "../simlib/OBB.min.js",
    "../simlib/ammo.wasm.js"
);

/**
 *
 * @param {string} operation The name of the operation that requires a deterministic implementation.
 * @throws {Error} Throws an error indicating that the operation does not have a deterministic implementation.
 */
function noDeterministicImplementationError(operation) {
    throw new Error(operation + ": No deterministic implementation");
}

const fastMathWasm = new WebAssembly.Instance(
    new WebAssembly.Module(
        Uint8Array.from(
            atob(
                "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"
            ),
            (c) => c.charCodeAt(0)
        )
    )
).exports;

const sineValues = [
    0, 0.01745240643728351, 0.03489949670250097, 0.05233595624294383,
    0.0697564737441253, 0.08715574274765817, 0.10452846326765346,
    0.12186934340514748, 0.13917310096006544, 0.15643446504023087,
    0.17364817766693033, 0.1908089953765448, 0.20791169081775931,
    0.22495105434386498, 0.24192189559966773, 0.25881904510252074,
    0.27563735581699916, 0.2923717047227367, 0.3090169943749474,
    0.3255681544571567, 0.3420201433256687, 0.35836794954530027,
    0.374606593415912, 0.3907311284892737, 0.40673664307580015,
    0.42261826174069944, 0.4383711467890774, 0.45399049973954675,
    0.4694715627858908, 0.48480962024633706, 0.49999999999999994,
    0.5150380749100542, 0.5299192642332049, 0.544639035015027,
    0.5591929034707468, 0.573576436351046, 0.5877852522924731,
    0.6018150231520483, 0.6156614753256583, 0.6293203910498375,
    0.6427876096865393, 0.6560590289905073, 0.6691306063588582,
    0.6819983600624985, 0.6946583704589973, 0.7071067811865475,
    0.7193398003386511, 0.7313537016191705, 0.7431448254773942,
    0.7547095802227719, 0.766044443118978, 0.7771459614569708,
    0.7880107536067219, 0.7986355100472928, 0.8090169943749475,
    0.8191520442889918, 0.8290375725550417, 0.8386705679454239,
    0.848048096156426, 0.8571673007021122, 0.8660254037844386,
    0.8746197071393957, 0.8829475928589269, 0.8910065241883678,
    0.898794046299167, 0.9063077870366499, 0.9135454576426009,
    0.9205048534524404, 0.9271838545667873, 0.9335804264972017,
    0.9396926207859083, 0.9455185755993167, 0.9510565162951535,
    0.9563047559630354, 0.9612616959383189, 0.9659258262890683,
    0.9702957262759965, 0.9743700647852352, 0.9781476007338057,
    0.981627183447664, 0.984807753012208, 0.9876883405951378,
    0.9902680687415704, 0.992546151641322, 0.9945218953682733,
    0.9961946980917455, 0.9975640502598242, 0.9986295347545738,
    0.9993908270190958, 0.9998476951563913, 1, 0.9998476951563913,
    0.9993908270190958, 0.9986295347545738, 0.9975640502598242,
    0.9961946980917455, 0.9945218953682734, 0.9925461516413221,
    0.9902680687415704, 0.9876883405951377, 0.984807753012208,
    0.981627183447664, 0.9781476007338057, 0.9743700647852352,
    0.9702957262759965, 0.9659258262890683, 0.9612616959383189,
    0.9563047559630355, 0.9510565162951536, 0.9455185755993168,
    0.9396926207859084, 0.9335804264972017, 0.9271838545667874,
    0.9205048534524404, 0.913545457642601, 0.90630778703665, 0.8987940462991669,
    0.8910065241883679, 0.8829475928589271, 0.8746197071393959,
    0.8660254037844387, 0.8571673007021123, 0.8480480961564261,
    0.8386705679454239, 0.8290375725550417, 0.819152044288992,
    0.8090169943749475, 0.7986355100472927, 0.788010753606722,
    0.777145961456971, 0.766044443118978, 0.7547095802227721,
    0.7431448254773945, 0.7313537016191706, 0.7193398003386511,
    0.7071067811865476, 0.6946583704589975, 0.6819983600624986,
    0.669130606358858, 0.6560590289905073, 0.6427876096865395,
    0.6293203910498374, 0.6156614753256584, 0.6018150231520486,
    0.5877852522924732, 0.5735764363510459, 0.5591929034707469,
    0.5446390350150273, 0.5299192642332049, 0.5150380749100544,
    0.49999999999999994, 0.48480962024633717, 0.4694715627858907,
    0.45399049973954686, 0.4383711467890777, 0.4226182617406995,
    0.40673664307580004, 0.39073112848927377, 0.37460659341591224,
    0.35836794954530066, 0.3420201433256689, 0.3255681544571566,
    0.3090169943749475, 0.29237170472273705, 0.2756373558169992,
    0.258819045102521, 0.24192189559966773, 0.2249510543438652,
    0.20791169081775931, 0.19080899537654497, 0.1736481776669307,
    0.15643446504023098, 0.13917310096006533, 0.12186934340514755,
    0.10452846326765373, 0.0871557427476582, 0.06975647374412552,
    0.05233595624294425, 0.03489949670250114, 0.01745240643728344,
    12246467991473532e-32, -0.017452406437283192, -0.0348994967025009,
    -0.052335956242943564, -0.06975647374412483, -0.08715574274765794,
    -0.1045284632676535, -0.12186934340514774, -0.13917310096006552,
    -0.15643446504023073, -0.17364817766693047, -0.19080899537654472,
    -0.20791169081775907, -0.22495105434386498, -0.2419218955996675,
    -0.25881904510252035, -0.2756373558169986, -0.29237170472273677,
    -0.30901699437494773, -0.32556815445715676, -0.34202014332566866,
    -0.35836794954530043, -0.374606593415912, -0.39073112848927355,
    -0.4067366430757998, -0.4226182617406993, -0.43837114678907707,
    -0.45399049973954625, -0.4694715627858905, -0.48480962024633734,
    -0.5000000000000001, -0.5150380749100542, -0.5299192642332048,
    -0.5446390350150271, -0.5591929034707467, -0.5735764363510458,
    -0.587785252292473, -0.601815023152048, -0.6156614753256578,
    -0.6293203910498372, -0.6427876096865393, -0.6560590289905074,
    -0.6691306063588582, -0.6819983600624984, -0.6946583704589974,
    -0.7071067811865475, -0.7193398003386509, -0.7313537016191705,
    -0.743144825477394, -0.7547095802227717, -0.7660444431189779,
    -0.7771459614569711, -0.7880107536067221, -0.7986355100472928,
    -0.8090169943749473, -0.8191520442889916, -0.8290375725550414,
    -0.838670567945424, -0.848048096156426, -0.8571673007021121,
    -0.8660254037844384, -0.8746197071393955, -0.882947592858927,
    -0.8910065241883678, -0.8987940462991668, -0.90630778703665,
    -0.913545457642601, -0.9205048534524403, -0.9271838545667873,
    -0.9335804264972016, -0.9396926207859082, -0.9455185755993168,
    -0.9510565162951535, -0.9563047559630353, -0.961261695938319,
    -0.9659258262890683, -0.9702957262759965, -0.9743700647852351,
    -0.9781476007338056, -0.981627183447664, -0.984807753012208,
    -0.9876883405951377, -0.9902680687415703, -0.992546151641322,
    -0.9945218953682733, -0.9961946980917455, -0.9975640502598242,
    -0.9986295347545739, -0.9993908270190958, -0.9998476951563913, -1,
    -0.9998476951563913, -0.9993908270190958, -0.9986295347545739,
    -0.9975640502598243, -0.9961946980917455, -0.9945218953682733,
    -0.992546151641322, -0.9902680687415704, -0.9876883405951378,
    -0.9848077530122081, -0.9816271834476641, -0.9781476007338056,
    -0.9743700647852352, -0.9702957262759966, -0.9659258262890684,
    -0.961261695938319, -0.9563047559630354, -0.9510565162951536,
    -0.945518575599317, -0.9396926207859083, -0.9335804264972017,
    -0.9271838545667874, -0.9205048534524405, -0.9135454576426011,
    -0.9063077870366503, -0.898794046299167, -0.8910065241883679,
    -0.8829475928589271, -0.8746197071393956, -0.8660254037844386,
    -0.8571673007021123, -0.8480480961564262, -0.8386705679454243,
    -0.8290375725550416, -0.8191520442889918, -0.8090169943749476,
    -0.798635510047293, -0.7880107536067223, -0.7771459614569713,
    -0.7660444431189781, -0.7547095802227722, -0.743144825477394,
    -0.7313537016191703, -0.7193398003386512, -0.7071067811865477,
    -0.6946583704589976, -0.6819983600624989, -0.6691306063588588,
    -0.6560590289905074, -0.6427876096865396, -0.6293203910498372,
    -0.6156614753256582, -0.6018150231520483, -0.5877852522924734,
    -0.5735764363510465, -0.5591929034707473, -0.544639035015027,
    -0.529919264233205, -0.5150380749100545, -0.5000000000000004,
    -0.48480962024633767, -0.4694715627858908, -0.45399049973954697,
    -0.4383711467890778, -0.4226182617406992, -0.40673664307580015,
    -0.3907311284892739, -0.37460659341591235, -0.35836794954530077,
    -0.34202014332566943, -0.3255681544571567, -0.3090169943749477,
    -0.29237170472273716, -0.27563735581699894, -0.2588190451025207,
    -0.24192189559966787, -0.22495105434386534, -0.20791169081775987,
    -0.19080899537654467, -0.1736481776669304, -0.15643446504023112,
    -0.13917310096006588, -0.12186934340514811, -0.1045284632676543,
    -0.08715574274765832, -0.06975647374412564, -0.05233595624294348,
    -0.034899496702500823, -0.01745240643728356,
];

// eslint-disable-next-line no-global-assign
Math = {
    E: 2.718281828459045,
    LN10: 2.302585092994046,
    LN2: 0.6931471805599453,
    LOG2E: 1.4426950408889634,
    LOG10E: 0.4342944819032518,
    PI: 3.141592653589793,
    SQRT1_2: 0.7071067811865476,
    SQRT2: 1.4142135623730951,
    abs: Math.abs,
    // @ts-ignore
    acos: fastMathWasm.acos,
    // @ts-ignore
    asin: fastMathWasm.asin,
    // @ts-ignore
    atan: fastMathWasm.atan,
    // @ts-ignore
    atan2: fastMathWasm.atan2,
    ceil: Math.ceil,
    cos: function (e) {
        return Math.sin(e + Math.PI / 2);
    },
    // @ts-ignore
    exp: fastMathWasm.exp,
    floor: Math.floor,
    // @ts-ignore
    log: fastMathWasm.log,
    max: Math.max,
    min: Math.min,
    // @ts-ignore
    pow: fastMathWasm.pow,
    random: Math.random,
    round: Math.round,
    sin: function (e) {
        if (!Number.isFinite(e)) return NaN;
        const t =
                ((e = (function (e) {
                    return ((e %= 2 * Math.PI) < 0 && (e += 2 * Math.PI), e);
                })(e)) /
                    (2 * Math.PI)) *
                sineValues.length,
            i = Math.floor(t),
            r = (i + 1) % sineValues.length,
            a = t - i;
        return sineValues[i] * (1 - a) + sineValues[r] * a;
    },
    // @ts-ignore
    sqrt: fastMathWasm.sqrt,
    // @ts-ignore
    tan: fastMathWasm.tan,
    // @ts-ignore
    clz32: () => noDeterministicImplementationError("clz32"),
    // @ts-ignore
    imul: () => noDeterministicImplementationError("imul"),
    sign: Math.sign,
    // @ts-ignore
    log10: fastMathWasm.log10,
    // @ts-ignore
    log2: fastMathWasm.log2,
    // @ts-ignore
    log1p: () => noDeterministicImplementationError("log1p"),
    // @ts-ignore
    expm1: () => noDeterministicImplementationError("expm1"),
    // @ts-ignore
    cosh: () => noDeterministicImplementationError("cosh"),
    // @ts-ignore
    sinh: () => noDeterministicImplementationError("sinh"),
    // @ts-ignore
    tanh: () => noDeterministicImplementationError("tanh"),
    // @ts-ignore
    acosh: () => noDeterministicImplementationError("acosh"),
    // @ts-ignore
    asinh: () => noDeterministicImplementationError("asinh"),
    // @ts-ignore
    atanh: () => noDeterministicImplementationError("atanh"),
    // @ts-ignore
    hypot: () => noDeterministicImplementationError("hypot"),
    trunc: Math.trunc,
    // @ts-ignore
    cbrt: () => noDeterministicImplementationError("cbrt"),
    fround: Math.fround,
    [Symbol.toStringTag]: "Math",
};

/**
 *
 * @param {string} base64
 * @returns {Uint8Array|null} Returns a Uint8Array if the base64 string is valid, otherwise returns null.
 */
function decodeBase64ToUint8Array(base64) {
    base64 = base64.replace(/-/g, "+").replace(/_/g, "/");
    let string;

    try {
        string = atob(base64);
        // eslint-disable-next-line no-unused-vars
    } catch (e) {
        return null;
    }

    const bytes = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
        const charCode = string.charCodeAt(i);

        if (charCode > 255) {
            return null; // Invalid character in base64 string
        }
        bytes[i] = charCode;
    }

    return bytes;
}

/**
 * Class to record and decode frame events.
 */
class FrameRecorder {
    /**
     * Maximum number of frames that can be recorded.
     * @type {number}
     */
    static maxFrames = 5999999;

    /**
     *
     * @constructor
     * @param {{upFrames: number[], downFrames: number[], leftFrames: number[], rightFrames: number[], resetFrames: number[]}|null} events Object containing arrays of frame events for different actions.
     */
    constructor(events) {
        /**
         * Array of frame numbers when the "up" action was toggled.
         * @type {number[]}
         */
        this.upFrames = [];
        /**
         * Array of frame numbers when the "down" action was toggled.
         * @type {number[]}
         */
        this.downFrames = [];
        /**
         * Array of frame numbers when the "left" action was toggled.
         * @type {number[]}
         */
        this.leftFrames = [];
        /**
         * Array of frame numbers when the "right" action was toggled.
         * @type {number[]}
         */
        this.rightFrames = [];
        /**
         * Array of frame numbers when the "reset" action was toggled.
         * @type {number[]}
         */
        this.resetFrames = [];

        if (events) {
            this.upFrames = events.upFrames;
            this.downFrames = events.downFrames;
            this.leftFrames = events.leftFrames;
            this.rightFrames = events.rightFrames;
            this.resetFrames = events.resetFrames;
        }
    }

    /**
     *
     * Example:
     * ```javascript
     * let states = [1, 3, 5, 7];
     * let frame = 4;
     * let count = FrameRecorder.countInputFlips(states, frame);
     * console.log(count); // Output: 2 - as there are two state changes (1 and 3) before frame 4.
     * ```
     *
     * @param {number[]} states Array of frame numbers representing the state changes.
     * @param {number} frame The frame number to check against the states.
     * @returns {number} Returns the count of input flips up to the specified frame.
     */
    static countInputFlips(states, frame) {
        let count = 0;

        for (let i = 0; i < states.length; i++) {
            if (states[i] === frame) {
                return count;
            }

            if (states[i] > frame) break;
            count++;
        }

        return count;
    }

    /**
     *
     * @param {number} frame The frame number for which to get the state.
     * @returns {{up: boolean, down: boolean, left: boolean, right: boolean, reset: boolean}} Returns the state of the frame for the given frame number.
     */

    getFrame(frame) {
        // If the number of changes is even, the input is considered inactive as all inputs start as inactive (on the first frame).
        // If the number of changes is odd, the input is considered active.

        return {
            up: FrameRecorder.countInputFlips(this.upFrames, frame) % 2 === 1,
            down:
                FrameRecorder.countInputFlips(this.downFrames, frame) % 2 === 1,
            left:
                FrameRecorder.countInputFlips(this.leftFrames, frame) % 2 === 1,
            right:
                FrameRecorder.countInputFlips(this.rightFrames, frame) % 2 ===
                1,
            reset:
                FrameRecorder.countInputFlips(this.resetFrames, frame) % 2 ===
                1,
        };
    }

    /**
     *
     * @param {Uint8Array} packetBuffer The packet (for one specific input) to decode.
     * @returns {number[]|null} Returns an array of frame numbers if the packet is valid, otherwise returns null.
     */
    static decodePacket(packetBuffer) {
        // Require at least 3 bytes to read the length
        if (packetBuffer.length < 3) return null;

        // Read the 3-byte little-endian integer
        const frameCount =
            packetBuffer[0] | (packetBuffer[1] << 8) | (packetBuffer[2] << 16);

        // Check if the packet is too short for the expected frame count
        if (packetBuffer.length < 3 + frameCount * 3) return null;

        const frameNumbers = [];

        for (let i = 0; i < frameCount; i++) {
            // Decode the 3-byte little-endian integer for each input state change frame
            const delta =
                packetBuffer[3 + i * 3] |
                (packetBuffer[4 + i * 3] << 8) |
                (packetBuffer[5 + i * 3] << 16);

            // The first value is absolute, subsequent values are the deltas (differences from the previous frame)
            if (i === 0) {
                frameNumbers.push(delta);
            } else {
                frameNumbers.push(frameNumbers[i - 1] + delta);
            }
        }

        return frameNumbers;
    }

    /**
     *
     * @param {string} base64
     * @returns {FrameRecorder|null} Returns a FrameRecorder instance if the base64 string is valid, otherwise returns null.
     */
    static deserialize(base64) {
        const buffer = decodeBase64ToUint8Array(base64);
        if (!buffer) return null;

        const inflate = new pako.Inflate();
        inflate.push(buffer, true);
        if (inflate.err != null) return null;

        const decompressedBuffer = inflate.result;
        if (!(decompressedBuffer instanceof Uint8Array)) return null;

        // Decode each input packet from the decompressed buffer
        let offset = 0;
        const upFrames = FrameRecorder.decodePacket(decompressedBuffer);
        if (upFrames == null) return null;
        offset += 3 + upFrames.length * 3;
        const rightFrames = FrameRecorder.decodePacket(
            decompressedBuffer.subarray(offset)
        );
        if (rightFrames == null) return null;
        offset += 3 + rightFrames.length * 3;
        const downFrames = FrameRecorder.decodePacket(
            decompressedBuffer.subarray(offset)
        );
        if (downFrames == null) return null;
        offset += 3 + downFrames.length * 3;
        const leftFrames = FrameRecorder.decodePacket(
            decompressedBuffer.subarray(offset)
        );
        if (leftFrames == null) return null;
        offset += 3 + leftFrames.length * 3;
        const resetFrames = FrameRecorder.decodePacket(
            decompressedBuffer.subarray(offset)
        );
        if (resetFrames == null) return null;

        return new FrameRecorder({
            upFrames: upFrames,
            rightFrames: rightFrames,
            downFrames: downFrames,
            leftFrames: leftFrames,
            resetFrames: resetFrames,
        });
    }
}

/**
 * Class representing a physics engine using Ammo.js.
 */
class PhysicsEngine {
    /**
     * The maximum physics steps per second.
     * @type {number}
     */
    static stepsPerSecond = 1000;
    /**
     * The size of the spatial grid used for collision detection.
     * This value determines how finely the world is divided into spatial cells for efficient collision detection.
     * A smaller value results in more cells, which can improve collision detection accuracy but may increase
     * computational overhead.
     * @type {number}
     */
    static spatialGridSize = 20;

    /**
     *
     * @constructor
     */
    constructor() {
        /**
         * The collision configuration for the physics engine.
         * @type {InstanceType<typeof Ammo.btDefaultCollisionConfiguration>}
         */
        this.collisionConfiguration =
            new Ammo.btDefaultCollisionConfiguration();
        /**
         * The collision dispatcher for the physics engine.
         * @type {InstanceType<typeof Ammo.btCollisionDispatcher>}
         */
        this.collisionDispatcher = new Ammo.btCollisionDispatcher(
            this.collisionConfiguration
        );
        /**
         * The broadphase for the physics engine, which is used for collision detection.
         * @type {InstanceType<typeof Ammo.btDbvtBroadphase>}
         */
        this.broadphase = new Ammo.btDbvtBroadphase();
        /**
         * The constraint solver for the physics engine, which is used to resolve constraints between bodies.
         * @type {InstanceType<typeof Ammo.btSequentialImpulseConstraintSolver>}
         */
        this.constraintSolver = new Ammo.btSequentialImpulseConstraintSolver();
        /**
         * The dynamics world for the physics engine, which is the main simulation world.
         * @type {InstanceType<typeof Ammo.btDiscreteDynamicsWorld>}
         */
        this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(
            this.collisionDispatcher,
            this.broadphase,
            this.constraintSolver,
            this.collisionConfiguration
        );

        // Set the gravity for the dynamics world.
        const gravityVector = new Ammo.btVector3(0, -9.82, 0);
        this.dynamicsWorld.setGravity(gravityVector);
        Ammo.destroy(gravityVector);

        /**
         *
         * @typedef {Object} StaticBodyData
         * @property {boolean} active - Whether the body is currently active in physics simulation
         * @property {InstanceType<typeof THREE.Matrix4>} matrix - Transform matrix for the body
         * @property {InstanceType<typeof Ammo.btCollisionShape>} shape - Bullet physics collision shape
         * @property {InstanceType<typeof Ammo.btRigidBody>|null} body - Bullet physics rigid body (null when inactive)
         * @property {InstanceType<typeof THREE.Vector3>} min - Minimum bounds of the body's AABB
         * @property {InstanceType<typeof THREE.Vector3>} max - Maximum bounds of the body's AABB
         */

        /**
         * Array of static bodies in the physics world.
         * @type {StaticBodyData[]}
         */
        this.staticBodies = [];
        /**
         * Map to store spatial hash data for collision detection.
         * @type {Map<number, Map<number, Map<number, StaticBodyData[]>>>}
         */
        this.spatialHashMap = new Map();
        /**
         * Array of active bodies in the physics world.
         * @type {StaticBodyData[]}
         */
        this.activeBodies = [];
        /**
         * Map to pool static body data for reuse.
         * This is used to avoid creating new objects for every static body, improving performance.
         * @type {Map<InstanceType<typeof Ammo.btCollisionShape>, InstanceType<typeof Ammo.btRigidBody>[]>}
         */
        this.bodyPool = new Map();
        /**
         * The ground plane in the physics world, used for collision detection.
         * @type {{body: InstanceType<typeof Ammo.btRigidBody>, shape: InstanceType<typeof Ammo.btStaticPlaneShape>, isActive: boolean}|null}
         */
        this.groundPlane = null;
        /**
         * The mountain terrain in the physics world, used for collision detection.
         * @type {{body: InstanceType<typeof Ammo.btRigidBody>, shape: InstanceType<typeof Ammo.btBvhTriangleMeshShape>, triangleMesh: InstanceType<typeof Ammo.btTriangleMesh>, offset: InstanceType<typeof THREE.Vector3>, minimumRadius: number, isActive: boolean}|null}
         */
        this.mountainTerrain = null;
    }

    /**
     * Disposes of the physics engine, cleaning up all resources and removing bodies from the dynamics world.
     * This method should be called when the physics engine is no longer needed to prevent memory leaks
     * and ensure that all resources are properly released.
     */
    dispose() {
        // Remove all active rigid bodies from the dynamics world.
        for (const { body: rigidBody } of this.activeBodies) {
            if (rigidBody) this.dynamicsWorld.removeRigidBody(rigidBody);
        }
        this.activeBodies = [];

        // Destory all static bodies and their motion states.
        for (const { body: rigidBody } of this.staticBodies) {
            if (rigidBody) {
                Ammo.destroy(rigidBody.getMotionState());
                Ammo.destroy(rigidBody);
            }
        }
        this.staticBodies = [];
        this.spatialHashMap.clear();

        // Destory all pooled bodies.
        for (const pooledBodies of this.bodyPool.values()) {
            for (const pooledBody of pooledBodies) {
                Ammo.destroy(pooledBody.getMotionState());
                Ammo.destroy(pooledBody);
            }
        }
        this.bodyPool.clear();

        // Clean up ground plane
        if (this.groundPlane) {
            if (this.groundPlane.isActive)
                this.dynamicsWorld.removeRigidBody(this.groundPlane.body);
            Ammo.destroy(this.groundPlane.body.getMotionState());
            Ammo.destroy(this.groundPlane.body);
            Ammo.destroy(this.groundPlane.shape);
        }

        // Clean up mountain terrain
        if (this.mountainTerrain) {
            if (this.mountainTerrain.isActive)
                this.dynamicsWorld.removeRigidBody(this.mountainTerrain.body);
            Ammo.destroy(this.mountainTerrain.body.getMotionState());
            Ammo.destroy(this.mountainTerrain.body);
            Ammo.destroy(this.mountainTerrain.shape);
            Ammo.destroy(this.mountainTerrain.triangleMesh);
        }

        // Destroy physics world components
        Ammo.destroy(this.dynamicsWorld);
        Ammo.destroy(this.constraintSolver);
        Ammo.destroy(this.broadphase);
        Ammo.destroy(this.collisionDispatcher);
        Ammo.destroy(this.collisionConfiguration);
    }

    /**
     * Creates a ground plane for the physics world.
     * This method initializes a static plane shape that acts as the ground in the physics simulation.
     * The ground plane is created at the origin with a normal pointing up along the Y-axis
     * and a margin of 0.01 units.
     * This ground plane is used to provide a surface for objects to collide with,
     * preventing them from falling indefinitely.
     * @throws {Error} If the ground plane is already initialized.
     */
    createGroundPlane() {
        if (this.groundPlane) throw new Error("Ground is already intialized");

        // Create plane normal pointing up (Y-axis)
        const planeNormal = new Ammo.btVector3(0, 1, 0);
        const planeShape = new Ammo.btStaticPlaneShape(planeNormal, 0);
        planeShape.setMargin(0.01);
        Ammo.destroy(planeNormal);

        // Set up transform at origin
        const transform = new Ammo.btTransform();
        transform.setIdentity();
        const motionState = new Ammo.btDefaultMotionState(transform);
        Ammo.destroy(transform);

        // Calculate inertia (0 for static body)
        const localInertia = new Ammo.btVector3();
        planeShape.calculateLocalInertia(0, localInertia);

        // Create rigid body
        const rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(
            0,
            motionState,
            planeShape,
            localInertia
        );
        const rigidBody = new Ammo.btRigidBody(rigidBodyInfo);
        rigidBody.setFriction(1);

        Ammo.destroy(localInertia);
        Ammo.destroy(rigidBodyInfo);

        this.groundPlane = {
            body: rigidBody,
            shape: planeShape,
            isActive: false, // Initially inactive
        };
    }

    /**
     * Creates a mountain terrain from a given set of vertex data.
     * This method initializes a triangle mesh shape for the mountains, allowing for complex terrain collision detection
     * using a set of vertices defined in a flat array.
     * The vertices should be provided in groups of 9, representing three vertices of a triangle
     * (each vertex consisting of 3 components: x, y, z).
     * The method also calculates the minimum distance from the origin to optimize collision detection.
     * @param {number[]} verticies - An array of vertex data in groups of 9 (3 vertices * 3 components each).
     * @param {InstanceType<typeof THREE.Vector3>} offset - The offset to apply to the mountain terrain's position in the physics world.
     * @throws {Error} If the number of vertices is not divisible by 9 or if mountains are already initialized.
     */
    createMountains(verticies, offset) {
        if (verticies.length % 9 !== 0)
            throw new Error(
                "Number of mountain verticies is not divisible by 9"
            );

        if (verticies.length > 0) {
            if (this.mountainTerrain)
                throw new Error("Mountains are already initialized");

            let minimumDistanceSquared = Infinity;
            const triangleMesh = new Ammo.btTriangleMesh();

            // Process verticies in groups of 9 (3 verticies * 3 components each)
            for (let i = 0; i < verticies.length; i += 9) {
                const v1 = new Ammo.btVector3(
                    verticies[i],
                    verticies[i + 1],
                    verticies[i + 2]
                );
                const v2 = new Ammo.btVector3(
                    verticies[i + 3],
                    verticies[i + 4],
                    verticies[i + 5]
                );
                const v3 = new Ammo.btVector3(
                    verticies[i + 6],
                    verticies[i + 7],
                    verticies[i + 8]
                );

                triangleMesh.addTriangle(v1, v2, v3);

                // Clean up vertex vectors
                Ammo.destroy(v1);
                Ammo.destroy(v2);
                Ammo.destroy(v3);

                // Track minimum distance from origin for optimization
                minimumDistanceSquared = Math.min(
                    minimumDistanceSquared,
                    new THREE.Vector3(
                        verticies[i],
                        verticies[i + 1],
                        verticies[i + 2]
                    ).lengthSq(),
                    new THREE.Vector3(
                        verticies[i + 3],
                        verticies[i + 4],
                        verticies[i + 5]
                    ).lengthSq(),
                    new THREE.Vector3(
                        verticies[i + 6],
                        verticies[i + 7],
                        verticies[i + 8]
                    ).lengthSq()
                );
            }

            // Create BVH triangle mesh shape for efficient collision detection
            // TODO: figure out if second parameter should be true or false
            const meshShape = new Ammo.btBvhTriangleMeshShape(
                triangleMesh,
                true
            );
            meshShape.setMargin(0.02);

            // Set up transform with offset
            const offsetVector = new Ammo.btVector3(
                offset.x,
                offset.y,
                offset.z
            );
            const transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(offsetVector);
            Ammo.destroy(offsetVector);

            // Calculate inertia (0 for static body)
            const localInertia = new Ammo.btVector3();
            meshShape.calculateLocalInertia(0, localInertia);

            const motionState = new Ammo.btDefaultMotionState(transform);
            Ammo.destroy(transform);

            // Create rigid body
            const rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(
                0,
                motionState,
                meshShape,
                localInertia
            );
            const rigidBody = new Ammo.btRigidBody(rigidBodyInfo);
            rigidBody.setFriction(1);

            Ammo.destroy(localInertia);
            Ammo.destroy(rigidBodyInfo);

            const minimumRadius = Math.sqrt(minimumDistanceSquared);

            this.mountainTerrain = {
                body: rigidBody,
                shape: meshShape,
                triangleMesh,
                offset,
                minimumRadius,
                isActive: false,
            };
        }
    }

    /**
     * Adds a static body to the physics world.
     * This method creates a static body with a specified transform matrix, bounding box, and collision
     * shape, and adds it to the spatial hash map for efficient collision detection.
     * The static body is not active by default and will not be simulated until activated.
     * The bounding box is transformed to world space using the provided transform matrix.
     * The spatial hash map is used to efficiently manage static bodies in the physics world,
     * allowing for quick lookups based on spatial coordinates.
     * @param {InstanceType<typeof THREE.Matrix4>} transformMatrix - The transformation matrix for the static body.
     * @param {InstanceType<typeof THREE.Box3>} boundingBox - The bounding box of the static body in local space.
     * @param {InstanceType<typeof Ammo.btCollisionShape>} collisionShape - The collision shape for the static body.
     */
    addStaticBody(transformMatrix, boundingBox, collisionShape) {
        // Transform bounding box to world space
        const worldBoundingBox = boundingBox.clone();
        worldBoundingBox.applyMatrix4(transformMatrix);

        const staticBodyData = {
            active: false,
            matrix: transformMatrix,
            shape: collisionShape,
            body: null,
            min: worldBoundingBox.min.clone(),
            max: worldBoundingBox.max.clone(),
        };

        // Add to spatial hash map with 3-unit buffer
        const minGridX = Math.floor(
            (worldBoundingBox.min.x - 3) / PhysicsEngine.spatialGridSize
        );
        const maxGridX = Math.ceil(
            (worldBoundingBox.max.x + 3) / PhysicsEngine.spatialGridSize
        );
        const minGridY = Math.floor(
            (worldBoundingBox.min.y - 3) / PhysicsEngine.spatialGridSize
        );
        const maxGridY = Math.ceil(
            (worldBoundingBox.max.y + 3) / PhysicsEngine.spatialGridSize
        );
        const minGridZ = Math.floor(
            (worldBoundingBox.min.z - 3) / PhysicsEngine.spatialGridSize
        );
        const maxGridZ = Math.ceil(
            (worldBoundingBox.max.z + 3) / PhysicsEngine.spatialGridSize
        );

        for (let x = minGridX; x <= maxGridX; x++) {
            for (let y = minGridY; y <= maxGridY; y++) {
                for (let z = minGridZ; z <= maxGridZ; z++) {
                    const xMap = this.spatialHashMap.get(x);
                    if (!xMap) {
                        // 💀💀💀
                        this.spatialHashMap.set(
                            x,
                            new Map([[y, new Map([[z, [staticBodyData]]])]])
                        );
                    } else {
                        const yMap = xMap.get(y);
                        if (!yMap) {
                            xMap.set(y, new Map([[z, [staticBodyData]]]));
                        } else {
                            const zArray = yMap.get(z);
                            if (zArray == null) {
                                yMap.set(z, [staticBodyData]);
                            } else {
                                zArray.push(staticBodyData);
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Activates/deactivates physics for bodies based on player position.
     * @param {InstanceType<typeof THREE.Vector3>} playerPosition - The position of the player in the physics world.
     * @throws {Error} If the rigid body is already active when trying to activate it.
     */
    activePhysicsAt(playerPosition) {
        // Handle ground plane activation based on player height
        if (this.groundPlane) {
            if (playerPosition.y < 4) {
                if (!this.groundPlane.isActive) {
                    this.dynamicsWorld.addRigidBody(this.groundPlane.body);
                    this.groundPlane.isActive = true;
                }
            } else if (playerPosition.y > 5) {
                if (this.groundPlane.isActive) {
                    this.dynamicsWorld.removeRigidBody(this.groundPlane.body);
                    this.groundPlane.isActive = false;
                }
            }
        }

        // Handle mountain terrain activation based on player distance
        if (this.mountainTerrain) {
            const distanceToMountains = playerPosition.distanceTo(
                this.mountainTerrain.offset
            );

            if (distanceToMountains > this.mountainTerrain.minimumRadius - 10) {
                if (!this.mountainTerrain.isActive) {
                    this.dynamicsWorld.addRigidBody(this.mountainTerrain.body);
                    this.mountainTerrain.isActive = true;
                }
            } else if (
                distanceToMountains <
                this.mountainTerrain.minimumRadius - 20
            ) {
                if (this.mountainTerrain.isActive) {
                    this.dynamicsWorld.removeRigidBody(
                        this.mountainTerrain.body
                    );
                    this.mountainTerrain.isActive = false;
                }
            }
        }

        // Deactivate bodies that are too far from player (with 3-unit buffer)
        this.activeBodies = this.activeBodies.filter((bodyData) => {
            if (
                bodyData.active &&
                (playerPosition.x < bodyData.min.x - 3 ||
                    playerPosition.x > bodyData.max.x + 3 ||
                    playerPosition.y < bodyData.min.y - 3 ||
                    playerPosition.y > bodyData.max.y + 3 ||
                    playerPosition.z < bodyData.min.z - 3 ||
                    playerPosition.z > bodyData.max.z + 3)
            ) {
                // Return body to pool for reuse
                const pool = this.bodyPool.get(bodyData.shape);
                if (pool == null) {
                    this.bodyPool.set(bodyData.shape, [bodyData.body]);
                } else {
                    pool.push(bodyData.body);
                }

                // Remove from dynamics world
                this.dynamicsWorld.removeRigidBody(bodyData.body);
                bodyData.body = null;
                bodyData.active = false;

                return false; // Deactivate this body
            }
            return true; // Keep the body active
        });

        // Calculate grid position for spatial hash lookup
        const gridPosition = playerPosition
            .clone()
            .divideScalar(PhysicsEngine.spatialGridSize)
            .floor();

        // Look up bodies in current grid cell
        const xMap = this.spatialHashMap.get(gridPosition.x);
        if (xMap) {
            const yMap = xMap.get(gridPosition.y);
            if (yMap) {
                const zArray = yMap.get(gridPosition.z);
                if (zArray) {
                    for (const bodyData of zArray) {
                        if (
                            !bodyData.active &&
                            playerPosition.x >= bodyData.min.x - 3 &&
                            playerPosition.x <= bodyData.max.x + 3 &&
                            playerPosition.y >= bodyData.min.y - 3 &&
                            playerPosition.y <= bodyData.max.y + 3 &&
                            playerPosition.z >= bodyData.min.z - 3 &&
                            playerPosition.z <= bodyData.max.z + 3
                        ) {
                            // Get or create body pool for this shape
                            let pool = this.bodyPool.get(bodyData.shape);
                            if (pool == null) {
                                pool = [];
                                this.bodyPool.set(bodyData.shape, pool);
                            }

                            // Set up transform
                            const transform = new Ammo.btTransform();
                            transform.setFromOpenGLMatrix(
                                bodyData.matrix.elements
                            );

                            let rigidBody;
                            if (pool.length > 0) {
                                // Reuse existing body from pool
                                rigidBody = pool.pop();
                                rigidBody.setWorldTransform(transform);
                                Ammo.destroy(transform);
                                this.dynamicsWorld.addRigidBody(rigidBody);
                            } else {
                                // Create new body
                                const motionState =
                                    new Ammo.btDefaultMotionState(transform);
                                Ammo.destroy(transform);

                                const localInertia = new Ammo.btVector3();
                                bodyData.shape.calculateLocalInertia(
                                    0,
                                    localInertia
                                );

                                const rigidBodyInfo =
                                    new Ammo.btRigidBodyConstructionInfo(
                                        0,
                                        motionState,
                                        bodyData.shape,
                                        localInertia
                                    );

                                rigidBody = new Ammo.btRigidBody(rigidBodyInfo);
                                rigidBody.setFriction(1);

                                Ammo.destroy(localInertia);
                                Ammo.destroy(rigidBodyInfo);
                                this.dynamicsWorld.addRigidBody(rigidBody);
                            }

                            if (bodyData.body)
                                throw new Error(
                                    "Activating already active rigid body"
                                );

                            bodyData.body = rigidBody;
                            bodyData.active = true;
                            this.activeBodies.push(bodyData);
                        }
                    }
                }
            }
        }
    }

    /**
     * Steps the physics simulation forward by one fixed time step.
     */
    step() {
        this.dynamicsWorld.stepSimulation(
            1 / PhysicsEngine.stepsPerSecond, // deltaTime
            0, // maxSubSteps (0 = no interpolation)
            1 / PhysicsEngine.stepsPerSecond // fixedTimeStep
        );
    }

    /**
     * Returns the dynamics world of the physics engine.
     * @returns {InstanceType<typeof Ammo.btDiscreteDynamicsWorld>} The dynamics world of the physics engine.
     */
    get world() {
        return this.dynamicsWorld;
    }

    /**
     * Returns the collision dispatcher of the physics engine.
     * @returns {InstanceType<typeof Ammo.btCollisionDispatcher>} The collision dispatcher of the physics
     */
    get dispatcher() {
        return this.collisionDispatcher;
    }
}

/**
 * Class to count frames in a simulation.
 */
class FrameCounter {
    /**
     *
     * @param {number} frames The number of frames to initialize the counter with.
     * @throws {Error} Throws an error if frames is not a safe integer.
     * @constructor
     */
    constructor(frames) {
        if (!Number.isSafeInteger(frames))
            throw new Error("Frames is not a safe integer");
        /**
         * The number of frames counted.
         * @type {number}
         */
        this.frames = frames;
    }

    /**
     * @returns {number} Returns the number of frames counted.
     */
    get numberOfFrames() {
        return this.frames;
    }

    /**
     * Increments the frame counter by one.
     */
    increment() {
        this.frames++;
    }

    /**
     *
     * @param {FrameCounter} other The other FrameCounter to compare with.
     * @returns {boolean} Returns true if this FrameCounter has fewer frames than the other, otherwise false.
     */
    lessThan(other) {
        return this.frames < other.frames;
    }

    /**
     *
     * @param {FrameCounter} other The other FrameCounter to compare with.
     * @returns {boolean} Returns true if this FrameCounter has fewer or equal frames than the other, otherwise false.
     */
    lessOrEqual(other) {
        return this.frames <= other.frames;
    }

    /**
     *
     * @param {FrameCounter} other The other FrameCounter to compare with.
     * @returns {boolean} Returns true if this FrameCounter has the same number of frames as the other, otherwise false.
     */
    equals(other) {
        return this.frames == other.frames;
    }

    /**
     * Creates a new FrameCounter instance with the same number of frames.
     * @returns {FrameCounter} Returns a new FrameCounter instance.
     */
    clone() {
        return new FrameCounter(this.frames);
    }
}

/**
 * Enum which represents the different stages of the race.
 * @type {{ Checkpoint: 0, Finish: 1 }}
 */
const RaceStage = {
    Checkpoint: 0,
    Finish: 1,
};

// TODO: determine the face normals & rotations for each row/column
/**
 * Array of pre-calculated quaternions for block rotations.
 * Each row represents a face normal to rotate around.
 * Each quaternion represents a 90-degree-multiple rotation around the corresponding face normal.
 * @type {InstanceType<typeof THREE.Quaternion>[][]}
 */
const blockRotationQuaternions = [
    [
        new THREE.Quaternion(0, 0, 0, 1),
        new THREE.Quaternion(0, 0.7071067811865475, 0, 0.7071067811865476),
        new THREE.Quaternion(0, 1, 0, 0),
        new THREE.Quaternion(0, 0.7071067811865476, 0, -0.7071067811865475),
    ],
    [
        new THREE.Quaternion(0, 0, 1, 0),
        new THREE.Quaternion(0.7071067811865475, 0, 0.7071067811865476, 0),
        new THREE.Quaternion(1, 0, 0, 0),
        new THREE.Quaternion(0.7071067811865476, 0, -0.7071067811865475, 0),
    ],
    [
        new THREE.Quaternion(0, 0, -0.7071067811865477, 0.7071067811865475),
        new THREE.Quaternion(0.5, 0.5, -0.5, 0.5),
        new THREE.Quaternion(0.7071067811865475, 0.7071067811865477, 0, 0),
        new THREE.Quaternion(0.5, 0.5, 0.5, -0.5),
    ],
    [
        new THREE.Quaternion(0, 0, 0.7071067811865475, 0.7071067811865476),
        new THREE.Quaternion(0.5, -0.5, 0.5, 0.5),
        new THREE.Quaternion(0.7071067811865476, -0.7071067811865475, 0, 0),
        new THREE.Quaternion(0.5, -0.5, -0.5, -0.5),
    ],
    [
        new THREE.Quaternion(0.7071067811865475, 0, 0, 0.7071067811865476),
        new THREE.Quaternion(0.5, 0.5, 0.5, 0.5),
        new THREE.Quaternion(0, 0.7071067811865476, 0.7071067811865475, 0),
        new THREE.Quaternion(-0.5, 0.5, 0.5, -0.5),
    ],
    [
        new THREE.Quaternion(-0.7071067811865477, 0, 0, 0.7071067811865475),
        new THREE.Quaternion(-0.5, -0.5, 0.5, 0.5),
        new THREE.Quaternion(0, -0.7071067811865475, 0.7071067811865477, 0),
        new THREE.Quaternion(0.5, -0.5, 0.5, -0.5),
    ],
];

/**
 * Returns the quaternion for a specific block rotation.
 * @param {number} faceNormalIndex The index of the face normal (0-5).
 * @param {number} rotationIndex The index of the rotation (0-3).
 * @returns {InstanceType<typeof THREE.Quaternion>} Returns the quaternion for the specified face normal and rotation index.
 */
function getBlockRotation(faceNormalIndex, rotationIndex) {
    return blockRotationQuaternions[faceNormalIndex][rotationIndex];
}

// TODO: implement the other structures (partprovider, etc.) & add their types
/**
 * Class to manage track parts (specifically checkpoints & finish lines) and their physics.
 */
class TrackManager {
    /**
     * The size of each part in the track.
     * @type {number}
     */
    static partSize = 5;

    /**
     * Creates a new TrackManager instance.
     * This constructor initializes the track manager with the provided physics engine, track data, and part provider.
     * It processes the parts provided by the part provider, categorizing them by type and
     * setting up the necessary physics for each part.
     * @param {InstanceType<typeof PhysicsEngine>} physicsEngine - The physics engine to use for the track parts.
     * @param {undefined} trackData - The track data containing information about the parts and their detectors.
     * @param {undefined} partProvider - The part provider that supplies the parts for the track.
     * @throws {Error} Throws an error if a part detector is missing or if a checkpoint has no checkpoint order.
     * @constructor
     */
    constructor(physicsEngine, trackData, partProvider) {
        this.trackData = trackData;
        this.partsByType = new Map();
        this.finishParts = [];
        this.checkpointParts = [];
        this.checkpointOrderList = [];

        partProvider.forEachPart(
            (
                x,
                y,
                z,
                rotation,
                rotationAxis,
                type,
                physics,
                checkpointOrder
            ) => {
                TrackManager.addPhysicsPart(
                    x,
                    y,
                    z,
                    rotation,
                    rotationAxis,
                    type,
                    physicsEngine,
                    trackData
                );

                const parts = this.partsByType.get(type);
                const partInfo = {
                    x,
                    y,
                    z,
                    rotation,
                    rotationAxis,
                    type,
                    checkpointOrder,
                };

                if (parts == null) {
                    this.partsByType.set(type, [partInfo]);
                } else {
                    parts.push(partInfo);
                }
            }
        );

        // Process finish parts
        for (const type of trackData.getPartTypesWithDetector(
            RaceStage.Finish
        )) {
            const detector = trackData.getDetector(type);
            if (!detector) throw new Error("Part detector is missing");

            const parts = this.partsByType.get(type);
            if (parts) {
                this.finishParts.push(
                    ...parts.map((p) => ({ ...p, detector }))
                );
            }
        }

        // Process checkpoint parts
        for (const type of trackData.getPartTypesWithDetector(
            RaceStage.Checkpoint
        )) {
            const detector = trackData.getDetector(type);
            if (!detector) throw new Error("Part detector is missing");

            const parts = this.partsByType.get(type);
            if (parts) {
                this.checkpointParts.push(
                    ...parts.map((p) => {
                        if (!p.checkpointOrder) {
                            throw new Error(
                                "Checkpoint has no checkpoint order"
                            );
                        }
                        return { ...p, detector };
                    })
                );
            }
        }

        // Extract unique checkpoint orders
        this.checkpointOrderList = [
            ...new Set(this.checkpointParts.map((p) => p.checkpointOrder)),
        ].sort((a, b) => a - b);
    }

    /**
     * Returns the total number of checkpoint indices.
     * @returns {number} The total number of checkpoint indices.
     */
    getTotalNumberOfCheckpointIndices() {
        return this.checkpointOrderList.length;
    }

    /**
     * Checks if the player is overlapping with a checkpoint.
     * @param {InstanceType<typeof THREE.Box3>} playerBox - The bounding box of the player.
     * @param {number} checkpointIndex - The index of the checkpoint to check against.
     * @returns {{x: number, y: number, z: number, rotation: number, rotationAxis: number, type: string}|null} Returns the part information if the player overlaps with the checkpoint, otherwise null.
     */
    checkCheckpoint(playerBox, checkpointIndex) {
        return this.checkOverlap(playerBox, checkpointIndex);
    }

    /**
     *
     * @param {InstanceType<typeof THREE.Box3>} playerBox - The bounding box of the player.
     * @returns {{x: number, y: number, z: number, rotation: number, rotationAxis: number, type: string}|null} Returns the part information if the player overlaps with the finish line, otherwise null.
     */
    checkFinish(playerBox) {
        return this.checkOverlap(playerBox, null);
    }

    /**
     *
     * @param {number} x The x-coordinate of the part.
     * @param {number} y The y-coordinate of the part.
     * @param {number} z The z-coordinate of the part.
     * @param {number} rotation The rotation index of the part.
     * @param {number} rotationAxis The rotation axis index of the part.
     * @param {number} type The type of the part.
     * @param {number} physicsEngine The physics engine to use for the part.
     * @param {number} trackData The track data containing information about the part's physics shape.
     */
    static addPhysicsPart(
        x,
        y,
        z,
        rotation,
        rotationAxis,
        type,
        physicsEngine,
        trackData
    ) {
        const quaternion = getBlockRotation(rotationAxis, rotation);
        const position = new THREE.Vector3(
            x * TrackManager.partSize,
            y * TrackManager.partSize,
            z * TrackManager.partSize
        );
        const matrix = new THREE.Matrix4().compose(
            position,
            quaternion,
            new THREE.Vector3(1, 1, 1)
        );

        const { boundingBox, shape } = trackData.getPhysicsShape(type);
        physicsEngine.addStaticBody(matrix, boundingBox, shape);
    }

    /**
     * Checks if the player is overlapping with a checkpoint or finish line.
     * This method checks the player's bounding box against all parts in the specified checkpoint index.
     * If the checkpoint index is null, it checks against the finish line parts.
     * It returns the part information if an overlap is detected, otherwise returns null.
     * @param {InstanceType<typeof THREE.Box3>} playerBox - The bounding box of the player.
     * @param {number|null} checkpointIndex - The index of the checkpoint to check against, or null to check the finish line.
     * @returns {{x: number, y: number, z: number, rotation: number, rotationAxis: number, type: string}|null} Returns the part information if an overlap is detected, otherwise null.
     */
    checkOverlap(playerBox, checkpointIndex) {
        const parts =
            checkpointIndex == null ? this.finishParts : this.checkpointParts;
        const targetOrder =
            checkpointIndex == null
                ? null
                : this.checkpointOrderList[checkpointIndex];

        for (const part of parts) {
            if (checkpointIndex != null && part.checkpointOrder !== targetOrder)
                continue;

            const quaternion = getBlockRotation(
                part.rotationAxis,
                part.rotation
            );
            const worldCenter = part.detector.center
                .clone()
                .applyQuaternion(quaternion)
                .add(
                    new THREE.Vector3(
                        part.x * TrackManager.partSize,
                        part.y * TrackManager.partSize,
                        part.z * TrackManager.partSize
                    )
                );

            const size = part.detector.size.clone().applyQuaternion(quaternion);
            size.set(Math.abs(size.x), Math.abs(size.y), Math.abs(size.z));

            const boundingBox = new THREE.Box3().setFromCenterAndSize(
                worldCenter,
                size
            );

            if (playerBox.intersectsBox(boundingBox)) {
                return {
                    x: part.x,
                    y: part.y,
                    z: part.z,
                    rotation: part.rotation,
                    rotationAxis: part.rotationAxis,
                    type: part.type,
                };
            }
        }

        return null;
    }
}
