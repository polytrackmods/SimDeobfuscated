const OBB = (() => {
    const {
            Box3: t,
            MathUtils: e,
            Matrix4: s,
            Matrix3: i,
            Ray: a,
            Vector3: n,
        } = THREE,
        r = { c: null, u: [new n(), new n(), new n()], e: [] },
        o = { c: null, u: [new n(), new n(), new n()], e: [] },
        h = [[], [], []],
        l = [[], [], []],
        c = [],
        u = new n(),
        S = new n(),
        z = new n(),
        f = new n(),
        m = new n(),
        d = new n(),
        y = new i(),
        p = new t(),
        M = new s(),
        x = new s(),
        b = new a();
    class w {
        constructor(t = new n(), e = new n(), s = new i()) {
            ((this.center = t), (this.halfSize = e), (this.rotation = s));
        }
        set(t, e, s) {
            return (
                (this.center = t),
                (this.halfSize = e),
                (this.rotation = s),
                this
            );
        }
        copy(t) {
            return (
                this.center.copy(t.center),
                this.halfSize.copy(t.halfSize),
                this.rotation.copy(t.rotation),
                this
            );
        }
        clone() {
            return new this.constructor().copy(this);
        }
        getSize(t) {
            return t.copy(this.halfSize).multiplyScalar(2);
        }
        clampPoint(t, s) {
            const i = this.halfSize;
            (f.subVectors(t, this.center),
                this.rotation.extractBasis(u, S, z),
                s.copy(this.center));
            const a = e.clamp(f.dot(u), -i.x, i.x);
            s.add(u.multiplyScalar(a));
            const n = e.clamp(f.dot(S), -i.y, i.y);
            s.add(S.multiplyScalar(n));
            const r = e.clamp(f.dot(z), -i.z, i.z);
            return (s.add(z.multiplyScalar(r)), s);
        }
        containsPoint(t) {
            return (
                f.subVectors(t, this.center),
                this.rotation.extractBasis(u, S, z),
                Math.abs(f.dot(u)) <= this.halfSize.x &&
                    Math.abs(f.dot(S)) <= this.halfSize.y &&
                    Math.abs(f.dot(z)) <= this.halfSize.z
            );
        }
        intersectsBox3(t) {
            return this.intersectsOBB(B.fromBox3(t));
        }
        intersectsSphere(t) {
            return (
                this.clampPoint(t.center, d),
                d.distanceToSquared(t.center) <= t.radius * t.radius
            );
        }
        intersectsOBB(t, e = Number.EPSILON) {
            ((r.c = this.center),
                (r.e[0] = this.halfSize.x),
                (r.e[1] = this.halfSize.y),
                (r.e[2] = this.halfSize.z),
                this.rotation.extractBasis(r.u[0], r.u[1], r.u[2]),
                (o.c = t.center),
                (o.e[0] = t.halfSize.x),
                (o.e[1] = t.halfSize.y),
                (o.e[2] = t.halfSize.z),
                t.rotation.extractBasis(o.u[0], o.u[1], o.u[2]));
            for (let t = 0; t < 3; t++)
                for (let e = 0; e < 3; e++) h[t][e] = r.u[t].dot(o.u[e]);
            (f.subVectors(o.c, r.c),
                (c[0] = f.dot(r.u[0])),
                (c[1] = f.dot(r.u[1])),
                (c[2] = f.dot(r.u[2])));
            for (let t = 0; t < 3; t++)
                for (let s = 0; s < 3; s++) l[t][s] = Math.abs(h[t][s]) + e;
            let s, i;
            for (let t = 0; t < 3; t++)
                if (
                    ((s = r.e[t]),
                    (i =
                        o.e[0] * l[t][0] + o.e[1] * l[t][1] + o.e[2] * l[t][2]),
                    Math.abs(c[t]) > s + i)
                )
                    return !1;
            for (let t = 0; t < 3; t++)
                if (
                    ((s =
                        r.e[0] * l[0][t] + r.e[1] * l[1][t] + r.e[2] * l[2][t]),
                    (i = o.e[t]),
                    Math.abs(c[0] * h[0][t] + c[1] * h[1][t] + c[2] * h[2][t]) >
                        s + i)
                )
                    return !1;
            return (
                (s = r.e[1] * l[2][0] + r.e[2] * l[1][0]),
                (i = o.e[1] * l[0][2] + o.e[2] * l[0][1]),
                !(
                    Math.abs(c[2] * h[1][0] - c[1] * h[2][0]) > s + i ||
                    ((s = r.e[1] * l[2][1] + r.e[2] * l[1][1]),
                    (i = o.e[0] * l[0][2] + o.e[2] * l[0][0]),
                    Math.abs(c[2] * h[1][1] - c[1] * h[2][1]) > s + i ||
                        ((s = r.e[1] * l[2][2] + r.e[2] * l[1][2]),
                        (i = o.e[0] * l[0][1] + o.e[1] * l[0][0]),
                        Math.abs(c[2] * h[1][2] - c[1] * h[2][2]) > s + i ||
                            ((s = r.e[0] * l[2][0] + r.e[2] * l[0][0]),
                            (i = o.e[1] * l[1][2] + o.e[2] * l[1][1]),
                            Math.abs(c[0] * h[2][0] - c[2] * h[0][0]) > s + i ||
                                ((s = r.e[0] * l[2][1] + r.e[2] * l[0][1]),
                                (i = o.e[0] * l[1][2] + o.e[2] * l[1][0]),
                                Math.abs(c[0] * h[2][1] - c[2] * h[0][1]) >
                                    s + i ||
                                    ((s = r.e[0] * l[2][2] + r.e[2] * l[0][2]),
                                    (i = o.e[0] * l[1][1] + o.e[1] * l[1][0]),
                                    Math.abs(c[0] * h[2][2] - c[2] * h[0][2]) >
                                        s + i ||
                                        ((s =
                                            r.e[0] * l[1][0] +
                                            r.e[1] * l[0][0]),
                                        (i =
                                            o.e[1] * l[2][2] +
                                            o.e[2] * l[2][1]),
                                        Math.abs(
                                            c[1] * h[0][0] - c[0] * h[1][0]
                                        ) >
                                            s + i ||
                                            ((s =
                                                r.e[0] * l[1][1] +
                                                r.e[1] * l[0][1]),
                                            (i =
                                                o.e[0] * l[2][2] +
                                                o.e[2] * l[2][0]),
                                            Math.abs(
                                                c[1] * h[0][1] - c[0] * h[1][1]
                                            ) >
                                                s + i ||
                                                ((s =
                                                    r.e[0] * l[1][2] +
                                                    r.e[1] * l[0][2]),
                                                (i =
                                                    o.e[0] * l[2][1] +
                                                    o.e[1] * l[2][0]),
                                                Math.abs(
                                                    c[1] * h[0][2] -
                                                        c[0] * h[1][2]
                                                ) >
                                                    s + i))))))))
                )
            );
        }
        intersectsPlane(t) {
            this.rotation.extractBasis(u, S, z);
            const e =
                    this.halfSize.x * Math.abs(t.normal.dot(u)) +
                    this.halfSize.y * Math.abs(t.normal.dot(S)) +
                    this.halfSize.z * Math.abs(t.normal.dot(z)),
                s = t.normal.dot(this.center) - t.constant;
            return Math.abs(s) <= e;
        }
        intersectRay(t, e) {
            return (
                this.getSize(m),
                p.setFromCenterAndSize(f.set(0, 0, 0), m),
                M.setFromMatrix3(this.rotation),
                M.setPosition(this.center),
                x.copy(M).invert(),
                b.copy(t).applyMatrix4(x),
                b.intersectBox(p, e) ? e.applyMatrix4(M) : null
            );
        }
        intersectsRay(t) {
            return null !== this.intersectRay(t, f);
        }
        fromBox3(t) {
            return (
                t.getCenter(this.center),
                t.getSize(this.halfSize).multiplyScalar(0.5),
                this.rotation.identity(),
                this
            );
        }
        equals(t) {
            return (
                t.center.equals(this.center) &&
                t.halfSize.equals(this.halfSize) &&
                t.rotation.equals(this.rotation)
            );
        }
        applyMatrix4(t) {
            const e = t.elements;
            let s = f.set(e[0], e[1], e[2]).length();
            const i = f.set(e[4], e[5], e[6]).length(),
                a = f.set(e[8], e[9], e[10]).length();
            (t.determinant() < 0 && (s = -s), y.setFromMatrix4(t));
            const n = 1 / s,
                r = 1 / i,
                o = 1 / a;
            return (
                (y.elements[0] *= n),
                (y.elements[1] *= n),
                (y.elements[2] *= n),
                (y.elements[3] *= r),
                (y.elements[4] *= r),
                (y.elements[5] *= r),
                (y.elements[6] *= o),
                (y.elements[7] *= o),
                (y.elements[8] *= o),
                this.rotation.multiply(y),
                (this.halfSize.x *= s),
                (this.halfSize.y *= i),
                (this.halfSize.z *= a),
                f.setFromMatrixPosition(t),
                this.center.add(f),
                this
            );
        }
    }
    const B = new w();
    return w;
})();
